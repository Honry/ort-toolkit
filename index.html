<body>
  <link href="sortable.min.css" rel="stylesheet" />
  <script src="sortable.min.js"></script>
  <script>
    'use strict';

    const backend = getParam('backend') || 'webgpu';
    let device = getParam('device') || 'cpu';
    const build = getParam('build') || 'self';
    const model = getParam('model') || 'mobilenetv2-7';

    const power = getParam('power') || 'default';
    const runTimes = getParam('runTimes') || 1;
    const warmupTimes = getParam('warmupTimes') || 10;
    const tasks = getParam('tasks') || 'performance';
    const wasmThreads = parseInt(getParam('wasmThreads')) || 4;

    // for developers
    const keepConsole = getParam('keepConsole') === 'true' || false;
    const ortDir = getParam('ortDir') || 'onnxruntimewebgpu';
    const profiling = getParam('profiling') || false;
    const verbose = getParam('verbose') === 'true' || false;

    if (backend === 'webgpu') {
      device = 'gpu';
    }
    let feeds;
    let profilingData = [];
    let profilingIndex = 0;
    let webgpuProfilingData = [];
    let webgpuProfilingIndex = 0;
    let warmupTimesLeft = warmupTimes;

    async function loadScript(url) {
      return new Promise((resolve, reject) => {
        const script = document.createElement('script');
        script.onload = resolve;
        script.onerror = reject;
        script.src = url;
        if (url.startsWith('http')) {
          script.crossOrigin = 'anonymous';
        }
        document.body.append(script);
      })
    }

    function getFeeds(model) {
      let feeds = {};
      let inputs = models[model];
      for (let key in inputs) {
        let value = inputs[key];
        feeds[key] = getTensor(value[0], value[1], value[2]);
      }
      return feeds;
    }

    function getParam(name) {
      name = name.replace(/[\[\]]/g, '\\$&');
      let regex = new RegExp('[?&]' + name + '(=([^&#]*)|&|#|$)', 'i');
      let results = regex.exec(window.location.href);
      if (!results)
        return null;
      if (!results[2])
        return '';
      return decodeURIComponent(results[2].replace(/\+/g, ' '));
    }

    function getTensor(dataType, shape, value) {
      let typedArray;
      if (dataType === 'uint16') {
        typedArray = Uint16Array;
      } else if (dataType === 'float16') {
        typedArray = Uint16Array;
      } else if (dataType === 'float32') {
        typedArray = Float32Array;
      } else if (dataType === 'int32') {
        typedArray = Int32Array;
      } else if (dataType === 'int64') {
        typedArray = BigInt64Array;
      }

      let data;
      if (Array.isArray(value)) {
        data = value;
      } else {
        let size = 1;
        shape.forEach((element) => {
          size *= element;
        });
        data = typedArray.from({ length: size }, () => value);
      }
      return new ort.Tensor(dataType, data, shape);
    }

    function processConsole(log) {
      let results;
      if (log.startsWith('{"cat"')) {
        let results = JSON.parse(log.replace(/,$/, ''));
        let args = results['args']
        if ('provider' in args) {
          let shape = /(\"input_type_shape.*),\"thread_scheduling_stats\"/.exec(log);
          profilingData.push([profilingIndex++, args['op_name'], parseInt(results['dur']), shape[1], args['provider']]);
        }
      } else if (log.startsWith('[profiling]')) {
        results = /\[profiling\] kernel \".*\[(.*)\].*\" (input.*), execution time\: (\d+) ns/.exec(log);
        if (results) {
          webgpuProfilingData.push([webgpuProfilingIndex++, results[1], parseInt(results[3]), results[2]]);
        }
      }
    }

    function getSum(data) {
      return data.reduce((accumulator, currentValue) => {
          return accumulator + currentValue
        }, 0);
    }

    function renderTask(task, data) {
      let p = document.createElement('p');
      document.body.appendChild(p);

      if (task === 'conformance') {
        p.innerText = `${task}: ${data}`;
        return;
      } else if (task === 'performance') {
        let totalTime = getSum(data);
        let averageTime = (totalTime / data.length).toFixed(2);
        p.innerText = `${task}: ${averageTime} (${data.join(', ')})`;
        return;
      }

      p.innerText = `${task}: ${data[0]}ms`;
      if (profiling) {
        renderProfiling(['Index', 'Kernel', 'Time (ns)', 'Shape', 'Provider'], profilingData);
      }
      renderAggregatedProfiling(['Kernel', 'Time (ns)', 'Percentage (%)'], webgpuProfilingData);
      renderProfiling(['Index', 'Kernel', 'Time (ns)', 'Shape'], webgpuProfilingData);

    }
    function renderAggregatedProfiling(heads, data) {
      let kernelTime = {};
      for (let d of data) {
        let kernel = d[1];
        if (!(kernel in kernelTime)) {
          kernelTime[kernel] = d[2];
        } else {
          kernelTime[kernel] += d[2];
        }
      }
      let totalTime = getSum(Object.values(kernelTime));
      let keys = Object.keys(kernelTime);
      let sortedKernelTime = keys.sort(function (a, b) {
        return kernelTime[b] - kernelTime[a];
      });
      let sortedAggregatedData = [];
      for (let kernel of sortedKernelTime) {
        let time = kernelTime[kernel]
        sortedAggregatedData.push([kernel, time, (time / totalTime * 100).toFixed(2)]);
      }

      renderProfiling(heads, sortedAggregatedData);
    }

    function renderProfiling(heads, data) {
      let row, th, td;

      // table
      let table = document.createElement('table');
      table.className = 'sortable';
      table.align = 'center';
      table.style.width = '80%';
      table.setAttribute('border', '1');
      document.body.appendChild(table);

      // thead
      let header = table.createTHead('thead');
      row = header.insertRow(0);
      row.style.fontWeight = 'bold';
      for (let head of heads) {
        let th = document.createElement('th');
        th.innerHTML = head;
        row.appendChild(th);
      }

      // tbody
      let tbody = document.createElement('tbody');
      table.appendChild(tbody);
      // rest of line
      for (let i = 0; i < data.length; ++i) {
        let info = data[i];
        row = tbody.insertRow(i);
        for (let j = 0; j < data[0].length; j++) {
          td = row.insertCell(j);
          td.innerHTML = info[j];
        }
      }

      // summary
      // todo

      document.body.appendChild(document.createElement('p'));
    }

    async function runTask(task, backend) {
      let totalTime = 0;
      let times = [];
      let oldConsoleLog;

      const option = {
        executionProviders: [
          {
            name: backend,
            deviceType: device,
            powerPreference: power,
          },
        ],
      };

      if (backend === 'wasm') {
        ort.env.wasm.numThreads = wasmThreads;
        ort.env.wasm.simd = true;
      }

      if (!keepConsole) {
        oldConsoleLog = console.log;
        console.log = function (log) {
          processConsole(log);
        };
      }

      for (var i = 0; i < warmupTimes + runTimes; i++) {
        if (i === warmupTimes && task === 'profiling') {
          if (profiling) {
            option.enableProfiling = true;
          }
          if (backend === 'webgpu') {
            ort.env.webgpu.profilingMode = 'default';
          }
        }

        const session = await ort.InferenceSession.create(`models/${model}.onnx`, option);
        const startTime = performance.now();
        const results = await session.run(feeds);
        if (task === 'conformance') {
          let result = results['output'].cpuData;
          return result;
        }
        if (i >= warmupTimes) {
          let elapsedTime = parseFloat((performance.now() - startTime).toFixed(2));
          times.push(elapsedTime);
          if (task === 'profiling') {
            if (backend === 'webgpu') {
              ort.env.webgpu.profilingMode = '';
            }
            if (profiling) {
              session.endProfiling();
            }
            if (!keepConsole) {
              console.log = oldConsoleLog;
            }
            break;
          }
        }
      }
      return times;
    }

    async function main() {
      let urls;
      if (build === 'ort') {
        urls = ['https://cdn.jsdelivr.net/npm/onnxruntime-web@latest/dist/ort.webgpu.min.js'];
      } else {
        urls = [`../../${ortDir}/onnxruntime/js/web/dist/ort.webgpu.min.js`];
      }
      urls = urls.concat(['models.js', 'util.js']);
      for (let url of urls) {
        await loadScript(url);
      }

      feeds = getFeeds(model);

      for (let task of tasks.split(',')) {
        if (task === 'conformance') {
          let backendOutput = await runTask('conformance', backend);
          let cpuOutput = await runTask('conformance', 'cpu');
          renderTask(task, compare(backendOutput, cpuOutput));
        } else {
          let times = await runTask(task, backend);
          renderTask(task, times);
        }
      }
    }

    main();
  </script>
</body>
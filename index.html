<body>
  <link href="sortable.min.css" rel="stylesheet" />
  <script src="sortable.min.js"></script>
  <script>
    'use strict';

    const backend = getParam('backend') || 'webgpu';
    let device = getParam('device') || 'cpu';
    const build = getParam('build') || 'self';
    const model = getParam('model') || 'mobilenetv2-7';
    const power = getParam('power') || 'default';
    const runTimes = getParam('runTimes') || 1;
    const warmupTimes = getParam('warmupTimes') || 1;
    const task = getParam('task') || 'performance';

    if (backend === 'webgpu') {
      device = 'gpu';
    }
    let feeds;
    let profileInfo = [];

    async function loadScript(url) {
      return new Promise((resolve, reject) => {
        const script = document.createElement('script');
        script.onload = resolve;
        script.onerror = reject;
        script.src = url;
        if (url.startsWith('http')) {
          script.crossOrigin = 'anonymous';
        }
        document.body.append(script);
      })
    }

    function getFeeds(ort, model) {
      let feeds = {};
      let inputs = models[model];
      for (let key in inputs) {
        let value = inputs[key];
        feeds[key] = getTensor(value[0], value[1], value[2]);
      }
      return feeds;
    }

    function getParam(name) {
      name = name.replace(/[\[\]]/g, '\\$&');
      let regex = new RegExp('[?&]' + name + '(=([^&#]*)|&|#|$)', 'i');
      let results = regex.exec(window.location.href);
      if (!results)
        return null;
      if (!results[2])
        return '';
      return decodeURIComponent(results[2].replace(/\+/g, ' '));
    }

    function getTensor(dataType, shape, value) {
      let typedArray;
      if (dataType === 'uint16') {
        typedArray = Uint16Array;
      } else if (dataType === 'float16') {
        typedArray = Uint16Array;
      } else if (dataType === 'float32') {
        typedArray = Float32Array;
      } else if (dataType === 'int32') {
        typedArray = Int32Array;
      } else if (dataType === 'int64') {
        typedArray = BigInt64Array;
      }

      let data;
      if (Array.isArray(value)) {
        data = value;
      } else {
        let size = 1;
        shape.forEach((element) => {
          size *= element;
        });
        data = typedArray.from({ length: size }, () => value);
      }
      return new ort.Tensor(dataType, data, shape);
    }

    function processProfile(log) {
      //const results = /\[profiling\] kernel \"\d+\|\[(\w+)\] \d+\" (input \w+), execution time: \d+ ns/.exec(log);
      const results = /\[profiling\] kernel \".*\[(.*)\].*\" (input.*), execution time\: (\d+) ns/.exec(log);
      profileInfo.push([results[1], results[3], results[2]]);
    }

    function renderProfile() {
      let row, th, td;

      // table
      let table = document.createElement('table');
      table.className = 'sortable';
      table.align = 'center';
      table.style.width = '80%';
      table.setAttribute('border', '1');
      document.body.appendChild(table);

      let header = table.createTHead('thead');
      row = header.insertRow(0);
      row.style.fontWeight = 'bold';
      th = document.createElement('th');
      th.innerHTML = 'Kernel';
      row.appendChild(th);
      th = document.createElement('th');
      th.innerHTML = 'Time (ns)';
      row.appendChild(th);
      th = document.createElement('th');
      th.innerHTML = 'Shape';
      row.appendChild(th);

      let tbody = document.createElement('tbody');
      table.appendChild(tbody);
      // rest of line
      for (let i = 0; i < profileInfo.length; ++i) {
        let info = profileInfo[i];
        row = tbody.insertRow(i);
        for (let j = 0; j < 3; j++) {
          td = row.insertCell(j);
          td.innerHTML = info[j];
        }
      }
    }

    async function runTask(backend) {
      let times = [];
      let totalTime = 0;
      let oldConsoleLog = console.log;

      const option = {
        executionProviders: [
          {
            name: backend,
            deviceType: device,
            powerPreference: power,
          },
        ],
      };

      if (task === 'profile') {
        //ort.env.logLevel = 'verbose';
        //option.enableProfiling = true;
      }

      if (backend === 'wasm') {
        ort.env.wasm.numThreads = 4;
        ort.env.wasm.simd = true;
      }

      const session = await ort.InferenceSession.create(`models/${model}.onnx`, option);

      for (var i = 0; i < warmupTimes + runTimes; i++) {
        const startTime = performance.now();
        if (task === 'profile' && i >= warmupTimes) {
          if (backend === 'webgpu') {
            ort.env.webgpu.profilingMode = 'default';
          }

          // override console.log
          console.log = function (log) {
            processProfile(log);
          };
        }
        const results = await session.run(feeds);
        if (task === 'conformance') {
          return results['output'].data;
        }
        if (i >= warmupTimes) {
          let elapsedTime = parseFloat((performance.now() - startTime).toFixed(2));
          totalTime += elapsedTime;
          times.push(elapsedTime);
          if (task === 'profile') {
            if (backend === 'webgpu') {
              ort.env.webgpu.profilingMode = '';
            }
            console.log = oldConsoleLog;
            return elapsedTime;
          }
        }
      }
      let averageTime = (totalTime / runTimes).toFixed(2);
      return averageTime;
    }

    async function main() {
      let urls;
      if (build === 'ort') {
        urls = ['https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.webgpu.min.js'];
      } else {
        urls = ['../../onnxruntimewebgpu/onnxruntime/js/web/dist/ort.webgpu.min.js'];
      }
      urls.push('models.js');
      for (let url of urls) {
        await loadScript(url);
      }

      feeds = getFeeds(ort, model);

      if (task === 'conformance') {
        let backendOutput = await runTask(backend);
        let cpuOutput = await runTask('cpu');
        console.log(compare(backendOutput, cpuOutput));
      } else if (task === 'performance') {
        let output = await runTask(backend);
        console.log(output);
      } else if (task === 'profile') {
        let output = await runTask(backend);
        renderProfile();
        console.log(output);
      }
    }

    main();
  </script>
</body>